# Amadevus.RecordGenerator

![RecordGenerator logo](https://raw.githubusercontent.com/amis92/RecordGenerator/master/docs/logo.png)

## Description
[Description]: #description

C# RecordGenerator Analyzer with record generating CodeFix. And the analyzer keeps watch over
your code to make sure the generated partial is always up-to-date, offering you another codefix
in case regeneration is due! How awesome is that?

[![NuGet package](https://img.shields.io/nuget/v/Amadevus.RecordGenerator.svg)](https://www.nuget.org/packages/Amadevus.RecordGenerator/)
[![Build status](https://img.shields.io/appveyor/ci/amis92/recordgenerator.svg)](https://ci.appveyor.com/project/amis92/recordgenerator/branch/master)
[![MyGet package](https://img.shields.io/myget/amadevus/v/Amadevus.RecordGenerator.svg?label=myget-ci)](https://www.myget.org/feed/amadevus/package/nuget/Amadevus.RecordGenerator)
[![Join the chat at gitter!](https://img.shields.io/gitter/room/amis92/recordgenerator.svg)](https://gitter.im/amis92/RecordGenerator?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
[![License](https://img.shields.io/github/license/amis92/recordgenerator.svg)](https://github.com/amis92/RecordGenerator/blob/master/LICENSE)

---

## Table of content
[Table of content]: #table-of-content

* [Description]
* [Installation]
* [Usage]
  * [Examples]
    * [Person]
    * [Enclosed type]
    * [Attribute parameters]
  * [Diagnostics]
* [Requirements]
* [Contributions]

## Installation
[Installation]: #installation

As it is a NuGet, it's really simple:

* Package Manager `Install-Package Amadevus.RecordGenerator`
* Or from `Manage NuGet packages` search for `Amadevus.RecordGenerator`

## Usage
[Usage]: #usage

Watch the gif below and then read on:

![Demo gif](https://raw.githubusercontent.com/amis92/RecordGenerator/master/docs/demo-v0.1.gif)

As you can see, it's very nice and easy. You just have to **decorate your class or struct
with `[Record]` attribute** and voila, you have a diagnostic with codefix available
at class identifier. If you haven't already declared such an attribute somewhere,
there is also a diagnostic with codefix that will do that for you - also show in demo above.

As presented, the generator creates new partial type with some members. Generator processes all
properties that are read-only and auto-implemented (which basically means they're
`public SomeType SomeName { get; }`) - from now on we'll call them record entries. Then there are
currently two kinds of members generated:

1. Constructor that has a parameter for every record entry, and assigns those parameters
   to corresponding auto-properties.
2. `With` mutators which take single record entry parameter and return new record instance
   with all values of record entries taken from current instance, except the parameter one which 
   is changed.

Additionally, after such file is generated, the analyzer monitors changes and gives error
if regeneration is required. That error also has available codefix which will update generated code.

### Examples
[Examples]: #examples

#### Person
[Person]: #person

Simple person record with different properties (builtin types like string, System type DateTime,
type parameter TDetails).

Given:

> `Person.cs`

```cs
using System;

namespace ClassLibrary1
{
    [Record]
    public partial class Person<TDetails>
    {
        public string FirstName { get; }

        public string LastName { get; }

        public string Address { get; }

        public DateTime Birthday { get; }

        public TDetails Details { get; }
    }
}
```

Generates:

> ``Person`1.RecordGenerator.cs``

```cs
// Record partial generated by RecordGenerator
// WARNING any changes made to this file will be lost when generator is run again

using System;

namespace ClassLibrary1
{
    [System.CodeDom.Compiler.GeneratedCode("RecordGenerator", "0.1.0.0")]
    partial class Person<TDetails>
    {
        public Person(string FirstName, string LastName, string Address, DateTime Birthday, TDetails Details)
        {
            this.FirstName = FirstName;
            this.LastName = LastName;
            this.Address = Address;
            this.Birthday = Birthday;
            this.Details = Details;
        }

        public Person<TDetails> WithFirstName(string FirstName)
        {
            return new Person<TDetails>(FirstName, LastName, Address, Birthday, Details);
        }

        public Person<TDetails> WithLastName(string LastName)
        {
            return new Person<TDetails>(FirstName, LastName, Address, Birthday, Details);
        }

        public Person<TDetails> WithAddress(string Address)
        {
            return new Person<TDetails>(FirstName, LastName, Address, Birthday, Details);
        }

        public Person<TDetails> WithBirthday(DateTime Birthday)
        {
            return new Person<TDetails>(FirstName, LastName, Address, Birthday, Details);
        }

        public Person<TDetails> WithDetails(TDetails Details)
        {
            return new Person<TDetails>(FirstName, LastName, Address, Birthday, Details);
        }
    }
}
```

All usings are copied over. Currently it's a safety net in case some property types require usings.
In future versions these usings may be simplified to include only those required.

#### Enclosed type
[Enclosed type]: #enclosed-type

Given:

> `History.cs`

```cs
using System.Collections.Generic;

namespace ClassLibrary1
{
    public partial class History
    {
        private IEnumerable<Entry> entries;

        [Record]
        private partial class Entry
        {
            public int Id { get; }

            public string Name { get; }

            public string Details { get; }
        }
    }
}
```

Generates:

> `History.Entry.RecordGenerator.cs`

```cs
// Record partial generated by RecordGenerator
// WARNING any changes made to this file will be lost when generator is run again

using System.Collections.Generic;

namespace ClassLibrary1
{
    partial class History
    {
        [System.CodeDom.Compiler.GeneratedCode("RecordGenerator", "0.1.0.0")]
        partial class Entry
        {
            public Entry(int Id, string Name, string Details)
            {
                this.Id = Id;
                this.Name = Name;
                this.Details = Details;
            }

            public Entry WithId(int Id)
            {
                return new Entry(Id, Name, Details);
            }

            public Entry WithName(string Name)
            {
                return new Entry(Id, Name, Details);
            }

            public Entry WithDetails(string Details)
            {
                return new Entry(Id, Name, Details);
            }
        }
    }
}
```

Currently enclosing type must be declared partial (not-enclosed records
are automatically fixed to become partial), besides the story is the same.

#### Attribute parameters
[Attribute parameters]: #attribute-parameters

There are currently two parameters available:

* `string ConstructorAccess` - defines access modifier of generated constructor, valid values:
  `public`/`protected`/`private`, default `public`.
* `bool GenerateMutators` - defines whether With- mutators should be generated, default `true`.

Given:

> `Person.cs`

```cs
using System;

namespace ClassLibrary1
{
    [Record(ConstructorAccess = "protected", GenerateMutators = false]
    public partial class Person
    {
        public string FirstName { get; }

        public string LastName { get; }

        public string Address { get; }

        public DateTime Birthday { get; }
    }
}
```

Generates:

> ``Person.RecordGenerator.cs``

```cs
// Record partial generated by RecordGenerator
// WARNING any changes made to this file will be lost when generator is run again

using System;

namespace ClassLibrary1
{
    [System.CodeDom.Compiler.GeneratedCode("RecordGenerator", "0.1.0.0")]
    partial class Person
    {
        protected Person(string FirstName, string LastName, string Address, DateTime Birthday)
        {
            this.FirstName = FirstName;
            this.LastName = LastName;
            this.Address = Address;
            this.Birthday = Birthday;
        }
    }
}
```

### Diagnostics
[Diagnostics]: #diagnostics

| Code | Title | Severity | Enabled by default | CodeFix| CodeFix action | Notes |
|:----:|:------|:--------:|:------------------:|:------:|:---------------|:------|
|RG0001|Missing RecordAttribute declaration|Warning|✔️|✔️| Creates new file containing RecordAttribute declaration. |
|RG0002|Missing record partial|Warning|✔️|✔️| Generates new file with partial type declaration containing record constructor and With- mutators. |
|RG0003|Invalid generated record partial|Error|✔️|✔️| Re-generates file with partial type declaration containing record constructor and With-mutators. | Diagnostic is raised when generation of record partial would result in different code than currently saved; raised when a change to in record type must be mirrored in generated file. |
|RG0004|Record partial was generated with different version of the tool|Info|✔️|✔️| See RG0003 CodeFix ||

## Requirements
[Requirements]: #requirements

![Visual Studio logo](https://upload.wikimedia.org/wikipedia/commons/6/61/Visual_Studio_2017_logo_and_wordmark.svg)

As this is a Roslyn Analyzer with CodeFix, it requires **Visual Studio 2015+** (~~it should also work
with **VS Code**~~ nope, until [OmniSharp/omnisharp-vscode#43](https://github.com/OmniSharp/omnisharp-vscode/issues/43)).

## Contributions
[Contributions]: #contributions

All contributions are welcome, as well as critique. If you have any issues, problems or suggestions -
please open an issue.

Visual Studio logo ™ Microsoft Corporation, used without permission.

RecordGenerator logo (on top) by Amadeusz Sadowski, all rights reserved.
